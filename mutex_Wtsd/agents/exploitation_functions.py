import numpy as np
import math

class NaiveDecay(object):

    def __init__(self, initial_eps, episode_shrinkage, limiting_epsiode, change_after_n_episodes):
        self.initial_eps = initial_eps
        self.episode_shrinkage = episode_shrinkage
        self.limiting_epsiode = limiting_epsiode
        self.change_after_n_episodes = change_after_n_episodes

    def apply(self, episode):
        if episode >= self.limiting_epsiode:
            return 0
        eps = self.initial_eps-(self.episode_shrinkage * (episode//self.change_after_n_episodes))
        eps = min(max(eps, 0), 1)
        return eps

class Constant(object):

    def __init__(self, value):
        self.value = value

    def apply(self, episode):
        return self.value


class GaussianDecay(object):

    def __init__(self, final, scaling, offset, max_steps):
        self.final = final
        self.scaling = scaling
        self.offset = offset
        self.weight = math.sqrt(-math.log(final)) / max_steps

    def apply(self, episode):
        return math.exp(-(self.weight * episode) ** 2) * self.scaling + self.offset


class ExpSawtoothEpsDecay(object):

    def __init__(self, initial_eps, episode_shrinkage, step_increase, limiting_epsiode, change_after_n_episodes):
        self.initial_eps = initial_eps
        self.episode_shrinkage = episode_shrinkage
        self.step_increase = step_increase
        self.limiting_epsiode = limiting_epsiode
        self.change_after_n_episodes = change_after_n_episodes

    def apply(self, episode):
        if episode >= self.limiting_epsiode:
            return 0
        eps = np.exp(-(0.0025 * episode) ** 2)
        # eps = eps + (self.step_increase * step / (episode+1))
        eps = min(max(eps, 0), 1)
        return eps


class ActionPathTreeNodes(object):

    def __init__(self):
        self.memory = {}

    def push_path(self, path):
        if path != "":
            key = path
        else:
            key = "first"
        if key in self.memory:
            self.memory[key] += 1
        else:
            self.memory[key] = 1

    def get_n_visits(self, path):
        if path != "":
            key = path
        else:
            key = "first"
        if key in self.memory:
            return self.memory[key]
        else:
            return 0

    def set_n_visits(self, path, visits):
        if path != "":
            key = path
        else:
            key = "first"
        self.memory[key] = visits

    def clear_memory(self):
        self.memory = {}