import numpy as np

class NaiveEpsDecay(object):

    def __init__(self, initial_eps, episode_shrinkage, limiting_epsiode, change_after_n_episodes):
        self.initial_eps = initial_eps
        self.episode_shrinkage = episode_shrinkage
        self.limiting_epsiode = limiting_epsiode
        self.change_after_n_episodes = change_after_n_episodes

    def apply(self, episode, step):
        if episode >= self.limiting_epsiode:
            return 0
        eps = self.initial_eps-(self.episode_shrinkage * (episode//self.change_after_n_episodes))
        eps = min(max(eps, 0), 1)
        return eps


class ExpSawtoothEpsDecay(object):

    def __init__(self, initial_eps, episode_shrinkage, step_increase, limiting_epsiode, change_after_n_episodes):
        self.initial_eps = initial_eps
        self.episode_shrinkage = episode_shrinkage
        self.step_increase = step_increase
        self.limiting_epsiode = limiting_epsiode
        self.change_after_n_episodes = change_after_n_episodes

    def apply(self, episode, step):
        if episode >= self.limiting_epsiode:
            return 0
        eps = np.exp(-(0.00016 * episode) ** 2)
        # eps = eps + (self.step_increase * step / (episode+1))
        eps = min(max(eps, 0), 1)
        return eps


class ActionPathTreeNodes(object):

    def __init__(self):
        self.memory = {}

    def push_path(self, path):
        if path != "":
            key = path
        else:
            key = "first"
        if key in self.memory:
            self.memory[key] += 1
        else:
            self.memory[key] = 1

    def get_n_visits(self, path):
        if path != "":
            key = path
        else:
            key = "first"
        if key in self.memory:
            return self.memory[key]
        else:
            return 0

    def set_n_visits(self, path, visits):
        if path != "":
            key = path
        else:
            key = "first"
        self.memory[key] = visits

    def clear_memory(self):
        self.memory = {}