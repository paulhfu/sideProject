\section{Using RL for predicting affinities}~\label{sec:rl_for_seg}

This work started with the idea of an RL setting where an agent manipulates affinities of pairs of pixels which form an input to the mutex wateshed algorithm \ref{sec:mtx_wtsd}. The edge set that mutex watershed typically receives is short range attractive edges and long lange repulsive edges where the length of the repulsive edges is dependent on the object sizes in the image. That means that there has to be at least one attractive edge for every neighboring pairs of pixels and some long range repulsive edge. Manipulating affinities is a hard task since there are simply so many. RL methods learns from rewards based on actions and an initial state. To achieve some convergence initially there need to be some rewards of a high value, that means that the actions taken lead to a fairly good segmentation. However when starting learning a networ from noise it outputs completely arbitrary actions that unlikely lead to a good results because the actions space is simply too large. The RL-typical bootstrapping works only if a high reward is likely even for random actions. It is not uncommon in RL to have many actions to predict while the reward is a single scalar value for a set of actions. If it would be possible to calculate more meaningful rewards, say per subregion in the image, one could compute a RL loss term for each such region only considering the actions that manipulated affinities within this region.\\

To downsize this problem, it is common in computer vision to work with superpixels \cite{10.1007/978-3-642-23094-3_3} rather than  with pixels. An a superpixel segmentation or oversegmentation us usually achieved by watersheding algorithms.
Using mutex watershed on can easily globally weaken attractive edges in order to arrive at an oversegmentation.
 Starting from such an oversegmentation and assuming that the ground-truth segmentation is a partitioning of the superpixels, one can focus solely on merging and unsmerging superpixels. For mutex watershed a merge of two superpixels would be done by turning all the repulsive edges between them into attractive ones and vice versa for unmerging. Therefore one needs a decision/action for every pair of superpixels. However there are two problems with this, first one can only perform hard merges and unmerges which leads likely to contradictions for example consider 3 adjacent superpixels and there are 2 merges and 1 unmerge predicted (see figure \ref{fig:seg_contradiction}).\\
 The second issue is, that for regular convolutional neural networks it is difficult to make predictions on affinities between adjacent superpixels.